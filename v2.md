# Commander Deckbuilding Knowledge Graph - Complete Implementation Plan

**Version 2.0 | MTGJSON with RelatedCards Integration**

---

## Project Overview

Build a property graph database for Commander deckbuilding recommendations using:
- **MTGJSON AtomicCards.json** - Core card data (oracle text, types, costs)
- **MTGJSON Keywords.json** - Standardized keyword list
- **MTGJSON RelatedCards.json** - Explicit combos, tokens, community pairings
- **Magic Comprehensive Rules** - Rules-based inference

**No external APIs** for pricing, statistics, or community data.

---

## Technology Stack

### **Graph Database**
- **Neo4j Community Edition** (free, local)
- Alternative: Neo4j Desktop (easier setup)

### **Data Sources**
- **MTGJSON v5** (https://mtgjson.com/api/v5/)
  - `AtomicCards.json` (~50MB) - Unique cards, no duplicate printings
  - `Keywords.json` (~5KB) - All MTG keywords
  - `RelatedCards.json` (~10MB) - Card relationships

### **Processing Stack**
```
Python 3.10+
├── neo4j (7.0+)          # Graph database driver
├── requests (2.31+)      # Download MTGJSON files
├── json (built-in)       # Parse card data
└── re (built-in)         # Text pattern matching
```

---

## Complete Graph Ontology

### **Node Types**

#### **1. Card**
```python
{
    # Intrinsic Properties (from MTGJSON AtomicCards)
    "name": str,
    "mana_cost": str,              # e.g., "{2}{U}{U}"
    "cmc": int,                    # mana value (MTGJSON: manaValue)
    "type_line": str,              # e.g., "Legendary Creature — Elf Druid"
    "oracle_text": str,            # full card text
    "color_identity": list[str],   # e.g., ["U", "B", "G"]
    "colors": list[str],           # actual colors (vs identity)
    "keywords": list[str],         # e.g., ["Flash", "Flying"]
    "is_legendary": bool,
    "is_reserved_list": bool,
    "edhrec_rank": int,            # popularity ranking
    
    # Derived Properties (computed from oracle text)
    "functional_categories": list[str],  # e.g., ["ramp", "draw"]
    "mechanics": list[str],              # e.g., ["etb_trigger", "cost_reduction"]
    "mana_efficiency": float,            # 0.0-1.0 heuristic score
    "color_pip_intensity": int,          # count of colored mana symbols
    "is_fast_mana": bool,                # produces mana, CMC ≤ 2
    "is_free_spell": bool,               # has alternative cost
}
```

#### **2. Commander** (inherits Card)
```python
{
    # All Card properties, plus:
    "can_be_commander": bool,          # from MTGJSON leadershipSkills
    "is_legendary": True,              # required
    
    # Derived commander-specific
    "primary_mechanics": list[str],    # parsed from oracle text
    "triggers_on": list[str],          # e.g., ["creature_etb", "spell_cast"]
    "provides_advantage": list[str],   # e.g., ["card_draw", "ramp"]
}
```

#### **3. Token**
```python
{
    "name": str,              # e.g., "Goblin", "Treasure", "Zombie"
    "type_line": str,         # e.g., "Token Creature — Goblin"
    "power_toughness": str,   # e.g., "1/1" (if known)
    "colors": list[str],      # token colors
    "keywords": list[str],    # e.g., ["Haste"]
}
```

#### **4. Mechanic**
```python
{
    "name": str,              # e.g., "etb_trigger", "Storm", "Flash"
    "category": str,          # "keyword", "triggered_ability", "static_ability"
    "description": str,       # rules explanation
}
```

#### **5. Functional_Role**
```python
{
    "name": str,              # e.g., "Ramp", "Card Draw", "Removal"
    "description": str,
    "typical_cmc_range": [int, int],  # e.g., [1, 3] for ramp
    "typical_count": [int, int],      # e.g., [8, 10] for ramp in decks
}
```

#### **6. Mana_Type**
```python
{
    "symbol": str,    # e.g., "{G}", "{U}", "{C}"
    "color": str,     # e.g., "Green", "Blue", "Colorless"
}
```

---

### **Relationship Types**

#### **1. [:HAS_MECHANIC]**
```cypher
(Card)-[:HAS_MECHANIC {
    is_primary: bool           # First mechanic is primary
}]->(Mechanic)
```

**Example:**
```cypher
(Eternal Witness)-[:HAS_MECHANIC {is_primary: true}]->(ETB_Trigger)
```

#### **2. [:FILLS_ROLE]**
```cypher
(Card)-[:FILLS_ROLE {
    efficiency_score: float,      # 0.0-1.0, derived from CMC vs effect
    conditionality: str,          # "unconditional", "conditional", "restrictive"
    context_dependent: bool       # requires board state
}]->(Functional_Role)
```

**Example:**
```cypher
(Nature's Lore)-[:FILLS_ROLE {
    efficiency_score: 0.9,
    conditionality: "unconditional"
}]->(Ramp)
```

#### **3. [:CREATES_TOKEN]** ✨ NEW
```cypher
(Card)-[:CREATES_TOKEN {
    source: str,           # "mtgjson_related_cards" or "oracle_text_parsed"
    count: str,            # "1", "X", "equal to..."
    token_type: str        # specific token name
}]->(Token)
```

**Example:**
```cypher
(Krenko, Mob Boss)-[:CREATES_TOKEN {
    source: "mtgjson_related_cards",
    count: "X",
    token_type: "Goblin"
}]->(Goblin_Token)
```

#### **4. [:COMBOS_WITH]** ✨ ENHANCED
```cypher
(Card)-[:COMBOS_WITH {
    source: str,            # "mtgjson_spellbook" (explicit) or "inferred" (heuristic)
    confidence: float,      # 1.0 for MTGJSON, 0.5-0.9 for inferred
    combo_type: str,        # "mana", "draw", "damage", "etb_loop"
    pieces_required: int,   # total cards needed
    additional_pieces: list[str],  # other required card names
    requires_board_state: str      # e.g., "2+ mana rocks"
}]->(Card)
```

**Example:**
```cypher
(Dramatic Reversal)-[:COMBOS_WITH {
    source: "mtgjson_spellbook",
    confidence: 1.0,
    combo_type: "mana",
    pieces_required: 2,
    requires_board_state: "2+ mana rocks producing 3+ mana total"
}]->(Isochron Scepter)
```

#### **5. [:COMMONLY_PAIRED_WITH]** ✨ NEW
```cypher
(Card)-[:COMMONLY_PAIRED_WITH {
    source: str,            # "mtgjson_reverse_related"
    pairing_type: str       # "combo", "synergy", "package"
}]->(Card)
```

**Example:**
```cypher
(Counterspell)-[:COMMONLY_PAIRED_WITH {
    source: "mtgjson_reverse_related",
    pairing_type: "package"
}]->(Isochron Scepter)
```

#### **6. [:SYNERGIZES_WITH_MECHANIC]**
```cypher
(Commander)-[:SYNERGIZES_WITH_MECHANIC {
    synergy_type: str,    # "triggers_on", "enables", "benefits_from"
    strength: float,      # 0.0-1.0 computed heuristic
    reason: str           # explanation (optional)
}]->(Mechanic)
```

**Example:**
```cypher
(Muldrotha)-[:SYNERGIZES_WITH_MECHANIC {
    synergy_type: "benefits_from",
    strength: 0.9,
    reason: "Can replay permanents to retrigger ETBs"
}]->(ETB_Trigger)
```

#### **7. [:PRODUCES_MANA]**
```cypher
(Card)-[:PRODUCES_MANA {
    amount: str,           # e.g., "{G}", "{C}{C}", "X"
    is_repeatable: bool,   # tap ability vs one-shot
    requires_tap: bool
}]->(Mana_Type)
```

#### **8. [:REQUIRES_MANA]**
```cypher
(Card)-[:REQUIRES_MANA {
    amount: int,
    phase: str  # "cast", "activated_ability", "maintenance"
}]->(Mana_Type)
```

#### **9. [:TUTORS_FOR]**
```cypher
(Card)-[:TUTORS_FOR {
    restriction: str,      # e.g., "creature", "artifact CMC ≤ 2"
    to_hand: bool,         # vs to battlefield vs to top
    cmc_restriction: int   # max CMC if applicable
}]->(Functional_Role)
```

#### **10. [:PROTECTS]**
```cypher
(Card)-[:PROTECTS {
    protection_type: str,  # "counterspell", "hexproof", "indestructible"
    is_conditional: bool
}]->(Card)
```

---

## Data Processing Pipeline

### **Phase 1: Data Acquisition**

#### **Step 1.1: Download MTGJSON Files**

```python
import requests
import json
import os

class MTGJSONDownloader:
    """Download and manage MTGJSON data files."""
    
    BASE_URL = "https://mtgjson.com/api/v5"
    DATA_DIR = "mtgjson_data"
    
    FILES = {
        "atomic_cards": "AtomicCards.json",
        "keywords": "Keywords.json",
        "related_cards": "RelatedCards.json"
    }
    
    @classmethod
    def download_all(cls):
        """Download all required MTGJSON files."""
        os.makedirs(cls.DATA_DIR, exist_ok=True)
        
        filepaths = {}
        
        for key, filename in cls.FILES.items():
            filepath = cls.download_file(filename)
            filepaths[key] = filepath
        
        return filepaths
    
    @classmethod
    def download_file(cls, filename: str) -> str:
        """Download a single MTGJSON file with progress."""
        url = f"{cls.BASE_URL}/{filename}"
        filepath = os.path.join(cls.DATA_DIR, filename)
        
        # Skip if already downloaded
        if os.path.exists(filepath):
            print(f"✓ {filename} already exists, skipping download")
            return filepath
        
        print(f"Downloading {filename}...")
        
        response = requests.get(url, stream=True)
        total_size = int(response.headers.get('content-length', 0))
        
        with open(filepath, 'wb') as f:
            downloaded = 0
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
                downloaded += len(chunk)
                
                # Progress indicator
                if total_size > 0:
                    percent = (downloaded / total_size) * 100
                    print(f"\r  Progress: {percent:.1f}%", end='')
        
        print(f"\n✓ Downloaded {filename}")
        return filepath

# Usage
downloader = MTGJSONDownloader()
files = downloader.download_all()
# Returns: {
#   "atomic_cards": "mtgjson_data/AtomicCards.json",
#   "keywords": "mtgjson_data/Keywords.json",
#   "related_cards": "mtgjson_data/RelatedCards.json"
# }
```

---

#### **Step 1.2: Parse MTGJSON AtomicCards**

```python
class AtomicCardsParser:
    """Parse MTGJSON AtomicCards.json structure."""
    
    @staticmethod
    def parse(filepath: str) -> list[dict]:
        """Parse and filter for Commander-legal cards."""
        
        print("Loading AtomicCards.json...")
        with open(filepath, 'r', encoding='utf-8') as f:
            raw_data = json.load(f)
        
        # MTGJSON structure: {"data": {"Card Name": [{card_object}, ...], ...}}
        cards_by_name = raw_data.get("data", {})
        
        commander_cards = []
        
        print("Filtering for Commander-legal cards...")
        for card_name, printings in cards_by_name.items():
            # Take first printing as canonical
            canonical = printings[0]
            
            # Check Commander legality
            legalities = canonical.get("legalities", {})
            if legalities.get("commander") != "Legal":
                continue
            
            # Extract card data
            card = {
                "name": card_name,
                "mana_cost": canonical.get("manaCost", ""),
                "cmc": canonical.get("manaValue", 0),
                "type_line": canonical.get("type", ""),
                "oracle_text": canonical.get("text", ""),
                "color_identity": canonical.get("colorIdentity", []),
                "colors": canonical.get("colors", []),
                "keywords": canonical.get("keywords", []),
                "is_legendary": "Legendary" in canonical.get("type", ""),
                "is_reserved_list": canonical.get("isReserved", False),
                "can_be_commander": canonical.get("leadershipSkills", {}).get("commander", False),
                "edhrec_rank": canonical.get("edhrecRank"),
            }
            
            commander_cards.append(card)
        
        print(f"✓ Parsed {len(commander_cards)} Commander-legal cards")
        return commander_cards

# Usage
parser = AtomicCardsParser()
cards = parser.parse(files["atomic_cards"])
```

---

#### **Step 1.3: Parse RelatedCards.json** ✨ NEW

```python
class RelatedCardsParser:
    """Parse MTGJSON RelatedCards.json."""
    
    @staticmethod
    def parse(filepath: str) -> dict:
        """Parse RelatedCards.json structure."""
        
        print("Loading RelatedCards.json...")
        with open(filepath, 'r', encoding='utf-8') as f:
            raw_data = json.load(f)
        
        # Structure: {"data": {"Card Name": {...}, ...}}
        related_data = raw_data.get("data", {})
        
        print(f"✓ Loaded relationships for {len(related_data)} cards")
        return related_data

# Usage
related_parser = RelatedCardsParser()
related_cards = related_parser.parse(files["related_cards"])

# Example structure:
# {
#   "Krenko, Mob Boss": {
#     "spellbook": [],
#     "tokens": ["Goblin"],
#     "reverseRelated": []
#   },
#   "Dramatic Reversal": {
#     "spellbook": ["Isochron Scepter"],
#     "tokens": [],
#     "reverseRelated": ["Isochron Scepter"]
#   }
# }
```

---

### **Phase 2: Text Parsing & Property Extraction**

#### **Step 2.1: Functional Role Detection**

```python
import re

class FunctionalRoleParser:
    """Parse oracle text to identify functional roles."""
    
    PATTERNS = {
        "ramp": [
            r"search (?:your library|a library) for (?:a|up to \d+).*\bland",
            r"put (?:a|up to \d+).*\bland.*onto the battlefield",
            r"add \{[WUBRGC]\}",
            r"(?:add|adds) [WUBRGC] to your mana pool",
            r"add .*mana",
        ],
        "card_draw": [
            r"draw (?:a|an|\d+|X) cards?",
            r"draw cards equal to",
            r"draws? (?:a|an|\d+) cards?",
        ],
        "removal": [
            r"destroy target (?:creature|permanent|artifact|enchantment)",
            r"exile target (?:creature|permanent|artifact|enchantment)",
            r"return target .* to (?:its owner's|their owner's) hand",
            r"(?:put|puts) target .* on (?:top|bottom) of (?:its|their) owner's library",
            r"-X/-X",
            r"destroy all creatures",
            r"exile all creatures",
        ],
        "counterspell": [
            r"counter target spell",
            r"counter (?:target )?(noncreature |instant |sorcery )?spell",
        ],
        "tutor": [
            r"search (?:your library|a library) for a card",
            r"search (?:your library|a library) for (?:a|an|up to \d+) (?:creature|instant|sorcery|artifact|enchantment|planeswalker)",
        ],
        "recursion": [
            r"return (?:target )?.*from (?:your|a|an) graveyard",
            r"return (?:target )?.*card from your graveyard to",
            r"put .*from your graveyard onto the battlefield",
        ],
        "token_generation": [
            r"create (?:a|an|\d+|X|one|two|three) .*tokens?",
            r"(?:put|puts) (?:a|an|\d+|X) .*tokens? onto the battlefield",
        ],
        "sacrifice_outlet": [
            r"sacrifice (?:a|an|one) (?:creature|permanent|artifact|enchantment)",
            r"sac a creature",
        ],
        "protection": [
            r"\bhexproof\b",
            r"\bindestructible\b",
            r"\bprotection from\b",
            r"\bshroud\b",
            r"\bward\b",
        ],
        "win_condition": [
            r"you win the game",
            r"(?:target player|each opponent) loses the game",
            r"(?:target player's?|each opponent's?) life total becomes",
        ],
    }
    
    @classmethod
    def identify_roles(cls, oracle_text: str) -> list[str]:
        """Return list of functional roles this card fills."""
        if not oracle_text:
            return []
        
        roles = []
        oracle_lower = oracle_text.lower()
        
        for role, patterns in cls.PATTERNS.items():
            for pattern in patterns:
                if re.search(pattern, oracle_lower):
                    roles.append(role)
                    break  # Don't double-count same role
        
        return roles

# Usage
oracle_text = "Search your library for a basic land card and put it onto the battlefield tapped."
roles = FunctionalRoleParser.identify_roles(oracle_text)
print(roles)  # Output: ["ramp"]
```

---

#### **Step 2.2: Mechanic Extraction**

```python
class MechanicExtractor:
    """Extract mechanics from keywords and oracle text."""
    
    TRIGGERED_ABILITY_PATTERNS = {
        "etb_trigger": r"[Ww]hen .* enters the battlefield",
        "dies_trigger": r"[Ww]hen .* (?:dies|is put into .* graveyard from the battlefield)",
        "attack_trigger": r"[Ww]henever .* attacks?",
        "cast_trigger": r"[Ww]henever (?:you cast|a player casts)",
        "draw_trigger": r"[Ww]henever (?:you draw|a player draws)",
        "sacrifice_trigger": r"[Ww]henever you sacrifice",
    }
    
    STATIC_ABILITY_PATTERNS = {
        "cost_reduction": r"(?:spells?|cards?) (?:you cast )?(?:cost|costs) \{?\d+\}? less",
        "anthem": r"(?:creatures?|permanents?) you control (?:get|have) \+\d+/\+\d+",
        "tax_effect": r"(?:spells?|abilities) .* (?:cost|costs) \{?\d+\}? more",
    }
    
    @classmethod
    def extract_mechanics(cls, card_data: dict) -> list[str]:
        """Extract all mechanics from card."""
        mechanics = []
        
        # 1. Keywords (pre-extracted by MTGJSON)
        keywords = card_data.get("keywords", [])
        mechanics.extend(keywords)
        
        # 2. Triggered abilities
        oracle_text = card_data.get("oracle_text", "")
        
        for mechanic, pattern in cls.TRIGGERED_ABILITY_PATTERNS.items():
            if re.search(pattern, oracle_text):
                mechanics.append(mechanic)
        
        # 3. Static abilities
        for mechanic, pattern in cls.STATIC_ABILITY_PATTERNS.items():
            if re.search(pattern, oracle_text):
                mechanics.append(mechanic)
        
        return list(set(mechanics))  # Remove duplicates

# Usage
card = {
    "name": "Eternal Witness",
    "oracle_text": "When Eternal Witness enters the battlefield, you may return target card from your graveyard to your hand.",
    "keywords": []
}
mechanics = MechanicExtractor.extract_mechanics(card)
print(mechanics)  # Output: ["etb_trigger"]
```

---

#### **Step 2.3: Calculate Derived Properties**

```python
class PropertyCalculator:
    """Calculate derived properties from card data."""
    
    @staticmethod
    def calculate_mana_efficiency(card: dict) -> float:
        """Heuristic: more effects per CMC = higher efficiency."""
        cmc = card.get("cmc", 0)
        
        if cmc == 0:
            return 1.0  # Free spells are maximally efficient
        
        # Count functional roles
        role_count = len(card.get("functional_categories", []))
        
        # Count keywords
        keyword_count = len(card.get("keywords", []))
        
        # Simple heuristic: (roles + 0.5*keywords) / (CMC + 1)
        efficiency = (role_count + keyword_count * 0.5) / (cmc + 1)
        
        return min(efficiency, 1.0)  # Cap at 1.0
    
    @staticmethod
    def count_color_pips(mana_cost: str) -> int:
        """Count colored mana symbols in cost."""
        if not mana_cost:
            return 0
        
        # Count {W}, {U}, {B}, {R}, {G} symbols
        colored_pips = re.findall(r'\{[WUBRG]\}', mana_cost)
        return len(colored_pips)
    
    @staticmethod
    def is_fast_mana(card: dict) -> bool:
        """Determine if card is fast mana (produces mana, low CMC)."""
        cmc = card.get("cmc", 0)
        oracle_text = card.get("oracle_text", "")
        
        if cmc > 2:
            return False
        
        # Check if produces mana
        produces_mana = bool(re.search(
            r"add \{[WUBRGC]\}",
            oracle_text,
            re.IGNORECASE
        ))
        
        return produces_mana
    
    @staticmethod
    def is_free_spell(card: dict) -> bool:
        """Check for alternative casting costs."""
        oracle_text = card.get("oracle_text", "")
        
        patterns = [
            r"you may .* rather than pay",
            r"if .* you may cast .* without paying",
            r"pitch",  # Pitch spells (Force of Will, etc.)
            r"alternate cost",
        ]
        
        for pattern in patterns:
            if re.search(pattern, oracle_text, re.IGNORECASE):
                return True
        
        return False

# Usage
card = {
    "name": "Sol Ring",
    "cmc": 1,
    "oracle_text": "{T}: Add {C}{C}.",
    "keywords": [],
    "functional_categories": ["ramp"]
}

efficiency = PropertyCalculator.calculate_mana_efficiency(card)
is_fast = PropertyCalculator.is_fast_mana(card)
print(f"Efficiency: {efficiency}, Fast Mana: {is_fast}")
# Output: Efficiency: 0.5, Fast Mana: True
```

---

#### **Step 2.4: Enrich Card Data**

```python
def enrich_card_data(cards: list[dict]) -> list[dict]:
    """Add derived properties to all cards."""
    
    role_parser = FunctionalRoleParser()
    mechanic_extractor = MechanicExtractor()
    property_calc = PropertyCalculator()
    
    enriched = []
    
    print("Enriching card data...")
    for i, card in enumerate(cards):
        # Functional roles
        card["functional_categories"] = role_parser.identify_roles(
            card.get("oracle_text", "")
        )
        
        # Mechanics
        card["mechanics"] = mechanic_extractor.extract_mechanics(card)
        
        # Derived properties
        card["mana_efficiency"] = property_calc.calculate_mana_efficiency(card)
        card["color_pip_intensity"] = property_calc.count_color_pips(
            card.get("mana_cost", "")
        )
        card["is_fast_mana"] = property_calc.is_fast_mana(card)
        card["is_free_spell"] = property_calc.is_free_spell(card)
        
        enriched.append(card)
        
        # Progress indicator
        if (i + 1) % 1000 == 0:
            print(f"  Processed {i + 1}/{len(cards)} cards...")
    
    print(f"✓ Enriched {len(enriched)} cards")
    return enriched

# Usage
enriched_cards = enrich_card_data(cards)
```

---

### **Phase 3: Graph Database Setup**

#### **Step 3.1: Neo4j Connection**

```python
from neo4j import GraphDatabase

class Neo4jConnection:
    """Manage Neo4j database connection."""
    
    def __init__(self, uri: str, user: str, password: str):
        """Initialize connection to Neo4j."""
        self.driver = GraphDatabase.driver(uri, auth=(user, password))
        print(f"✓ Connected to Neo4j at {uri}")
    
    def close(self):
        """Close database connection."""
        self.driver.close()
        print("✓ Connection closed")
    
    def execute_query(self, query: str, parameters: dict = None):
        """Execute a Cypher query."""
        with self.driver.session() as session:
            result = session.run(query, parameters or {})
            return [record.data() for record in result]
    
    def create_constraints(self):
        """Create uniqueness constraints and indexes."""
        
        constraints = [
            # Uniqueness constraints
            "CREATE CONSTRAINT card_name IF NOT EXISTS FOR (c:Card) REQUIRE c.name IS UNIQUE",
            "CREATE CONSTRAINT commander_name IF NOT EXISTS FOR (c:Commander) REQUIRE c.name IS UNIQUE",
            "CREATE CONSTRAINT mechanic_name IF NOT EXISTS FOR (m:Mechanic) REQUIRE m.name IS UNIQUE",
            "CREATE CONSTRAINT role_name IF NOT EXISTS FOR (r:Functional_Role) REQUIRE r.name IS UNIQUE",
            "CREATE CONSTRAINT token_name IF NOT EXISTS FOR (t:Token) REQUIRE t.name IS UNIQUE",
            
            # Indexes for performance
            "CREATE INDEX card_cmc IF NOT EXISTS FOR (c:Card) ON (c.cmc)",
            "CREATE INDEX card_color_identity IF NOT EXISTS FOR (c:Card) ON (c.color_identity)",
            "CREATE INDEX card_is_legendary IF NOT EXISTS FOR (c:Card) ON (c.is_legendary)",
        ]
        
        print("Creating constraints and indexes...")
        for constraint in constraints:
            try:
                self.execute_query(constraint)
            except Exception as e:
                # Constraint might already exist
                pass
        
        print("✓ Constraints and indexes created")

# Usage
conn = Neo4jConnection(
    uri="bolt://localhost:7687",
    user="neo4j",
    password="your_password_here"
)
conn.create_constraints()
```

---

#### **Step 3.2: Load Cards into Graph**

```python
def load_card_to_graph(conn: Neo4jConnection, card_data: dict):
    """Create Card or Commander node in graph."""
    
    # Determine node label
    is_commander = (
        card_data.get("is_legendary") and 
        card_data.get("can_be_commander")
    )
    
    node_label = "Commander" if is_commander else "Card"
    
    query = f"""
    MERGE (c:{node_label} {{name: $name}})
    SET c.mana_cost = $mana_cost,
        c.cmc = $cmc,
        c.type_line = $type_line,
        c.oracle_text = $oracle_text,
        c.color_identity = $color_identity,
        c.colors = $colors,
        c.keywords = $keywords,
        c.is_legendary = $is_legendary,
        c.is_reserved_list = $is_reserved_list,
        c.edhrec_rank = $edhrec_rank,
        c.functional_categories = $functional_categories,
        c.mechanics = $mechanics,
        c.mana_efficiency = $mana_efficiency,
        c.color_pip_intensity = $color_pip_intensity,
        c.is_free_spell = $is_free_spell,
        c.is_fast_mana = $is_fast_mana
    """
    
    # For commanders, add additional properties
    if is_commander:
        query += """,
        c.can_be_commander = $can_be_commander
        """
    
    params = {
        "name": card_data["name"],
        "mana_cost": card_data.get("mana_cost", ""),
        "cmc": card_data.get("cmc", 0),
        "type_line": card_data.get("type_line", ""),
        "oracle_text": card_data.get("oracle_text", ""),
        "color_identity": card_data.get("color_identity", []),
        "colors": card_data.get("colors", []),
        "keywords": card_data.get("keywords", []),
        "is_legendary": card_data.get("is_legendary", False),
        "is_reserved_list": card_data.get("is_reserved_list", False),
        "edhrec_rank": card_data.get("edhrec_rank"),
        "functional_categories": card_data.get("functional_categories", []),
        "mechanics": card_data.get("mechanics", []),
        "mana_efficiency": card_data.get("mana_efficiency", 0.0),
        "color_pip_intensity": card_data.get("color_pip_intensity", 0),
        "is_free_spell": card_data.get("is_free_spell", False),
        "is_fast_mana": card_data.get("is_fast_mana", False),
        "can_be_commander": card_data.get("can_be_commander", False),
    }
    
    conn.execute_query(query, params)


def batch_load_cards(conn: Neo4jConnection, cards: list[dict]):
    """Load all cards in batches for performance."""
    
    batch_size = 100
    total = len(cards)
    
    print(f"Loading {total} cards into graph...")
    
    for i in range(0, total, batch_size):
        batch = cards[i:i+batch_size]
        
        for card in batch:
            load_card_to_graph(conn, card)
        
        if (i + batch_size) % 1000 == 0:
            print(f"  Loaded {min(i + batch_size, total)}/{total} cards...")
    
    print(f"✓ Loaded {total} cards")

# Usage
batch_load_cards(conn, enriched_cards)
```

---

### **Phase 4: Create Relationships**

#### **Step 4.1: Mechanic Relationships**

```python
def create_mechanic_relationships(conn: Neo4jConnection, card_data: dict):
    """Create [:HAS_MECHANIC] relationships."""
    
    card_name = card_data["name"]
    mechanics = card_data.get("mechanics", [])
    
    for i, mechanic in enumerate(mechanics):
        # Create mechanic node if doesn't exist
        query_mechanic = """
        MERGE (m:Mechanic {name: $mechanic_name})
        """
        conn.execute_query(query_mechanic, {"mechanic_name": mechanic})
        
        # Create relationship
        query_rel = """
        MATCH (c:Card {name: $card_name})
        MATCH (m:Mechanic {name: $mechanic_name})
        MERGE (c)-[:HAS_MECHANIC {is_primary: $is_primary}]->(m)
        """
        
        # First mechanic is primary
        is_primary = (i == 0)
        
        conn.execute_query(query_rel, {
            "card_name": card_name,
            "mechanic_name": mechanic,
            "is_primary": is_primary
        })

# Usage (in batch)
for card in enriched_cards:
    create_mechanic_relationships(conn, card)
```

---

#### **Step 4.2: Functional Role Relationships**

```python
def create_role_relationships(conn: Neo4jConnection, card_data: dict):
    """Create [:FILLS_ROLE] relationships."""
    
    card_name = card_data["name"]
    roles = card_data.get("functional_categories", [])
    oracle_text = card_data.get("oracle_text", "").lower()
    
    for role in roles:
        # Create role node if doesn't exist
        query_role = """
        MERGE (r:Functional_Role {name: $role_name})
        """
        conn.execute_query(query_role, {"role_name": role})
        
        # Determine conditionality
        conditionality = "unconditional"
        if any(word in oracle_text for word in ["if", "when", "whenever", "as long as"]):
            conditionality = "conditional"
        if any(word in oracle_text for word in ["unless", "only if", "may"]):
            conditionality = "restrictive"
        
        # Create relationship
        query_rel = """
        MATCH (c:Card {name: $card_name})
        MATCH (r:Functional_Role {name: $role_name})
        MERGE (c)-[:FILLS_ROLE {
            efficiency_score: $efficiency,
            conditionality: $conditionality
        }]->(r)
        """
        
        conn.execute_query(query_rel, {
            "card_name": card_name,
            "role_name": role,
            "efficiency": card_data.get("mana_efficiency", 0.5),
            "conditionality": conditionality
        })

# Usage (in batch)
for card in enriched_cards:
    create_role_relationships(conn, card)
```

---

#### **Step 4.3: RelatedCards Relationships** ✨ NEW

```python
def create_related_card_relationships(conn: Neo4jConnection, 
                                      card_name: str, 
                                      related_data: dict):
    """Create relationships from MTGJSON RelatedCards.json."""
    
    if not related_data:
        return
    
    # 1. SPELLBOOK: Explicit combos/synergies
    spellbook = related_data.get("spellbook", [])
    for related_card in spellbook:
        query = """
        MATCH (c1:Card {name: $card_name})
        MATCH (c2:Card {name: $related_card})
        MERGE (c1)-[:COMBOS_WITH {
            source: "mtgjson_spellbook",
            confidence: 1.0
        }]->(c2)
        """
        
        try:
            conn.execute_query(query, {
                "card_name": card_name,
                "related_card": related_card
            })
        except Exception:
            # Related card might not be Commander-legal
            pass
    
    # 2. TOKENS: Token generation
    tokens = related_data.get("tokens", [])
    for token_name in tokens:
        # Create token node
        query_token = """
        MERGE (t:Token {name: $token_name})
        """
        conn.execute_query(query_token, {"token_name": token_name})
        
        # Create relationship
        query_rel = """
        MATCH (c:Card {name: $card_name})
        MATCH (t:Token {name: $token_name})
        MERGE (c)-[:CREATES_TOKEN {
            source: "mtgjson_related_cards"
        }]->(t)
        """
        
        conn.execute_query(query_rel, {
            "card_name": card_name,
            "token_name": token_name
        })
    
    # 3. REVERSE RELATED: Community pairings
    reverse_related = related_data.get("reverseRelated", [])
    for related_card in reverse_related:
        query = """
        MATCH (c1:Card {name: $card_name})
        MATCH (c2:Card {name: $related_card})
        MERGE (c1)-[:COMMONLY_PAIRED_WITH {
            source: "mtgjson_reverse_related"
        }]->(c2)
        """
        
        try:
            conn.execute_query(query, {
                "card_name": card_name,
                "related_card": related_card
            })
        except Exception:
            pass


def integrate_related_cards(conn: Neo4jConnection, 
                           related_cards_data: dict):
    """Integrate all RelatedCards.json data into graph."""
    
    total = len(related_cards_data)
    processed = 0
    
    print(f"Integrating RelatedCards for {total} cards...")
    
    for card_name, relationships in related_cards_data.items():
        create_related_card_relationships(conn, card_name, relationships)
        processed += 1
        
        if processed % 1000 == 0:
            print(f"  Processed {processed}/{total}...")
    
    print(f"✓ Integrated {processed} card relationships")

# Usage
integrate_related_cards(conn, related_cards)
```

---

### **Phase 5: Commander Synergy Inference**

#### **Step 5.1: Synergy Inference Engine**

```python
class SynergyInferenceEngine:
    """Infer synergies between commanders and mechanics."""
    
    @staticmethod
    def analyze_commander(conn: Neo4jConnection, commander_name: str):
        """Analyze commander oracle text to determine synergies."""
        
        # Get commander data
        query = """
        MATCH (c:Commander {name: $name})
        RETURN c.oracle_text AS oracle_text, 
               c.keywords AS keywords,
               c.mechanics AS mechanics
        """
        result = conn.execute_query(query, {"name": commander_name})
        
        if not result:
            print(f"⚠ Commander '{commander_name}' not found")
            return
        
        oracle_text = result[0]["oracle_text"].lower()
        keywords = result[0].get("keywords", [])
        existing_mechanics = result[0].get("mechanics", [])
        
        synergies = []
        
        # ETB synergy
        if "enters the battlefield" in oracle_text or "etb_trigger" in existing_mechanics:
            synergies.append({
                "mechanic": "etb_trigger",
                "synergy_type": "triggers_on",
                "strength": 0.9,
                "reason": "Commander triggers or benefits from ETBs"
            })
        
        # Dies/sacrifice synergy
        if any(word in oracle_text for word in ["dies", "sacrific", "death trigger"]):
            synergies.append({
                "mechanic": "dies_trigger",
                "synergy_type": "triggers_on",
                "strength": 0.9,
                "reason": "Commander triggers on deaths"
            })
            synergies.append({
                "mechanic": "sacrifice_outlet",
                "synergy_type": "benefits_from",
                "strength": 0.8,
                "reason": "Synergizes with sacrifice outlets"
            })
        
        # Cast trigger synergy
        if "whenever you cast" in oracle_text or "cast_trigger" in existing_mechanics:
            synergies.append({
                "mechanic": "cast_trigger",
                "synergy_type": "triggers_on",
                "strength": 0.8,
                "reason": "Commander triggers on spell casts"
            })
        
        # Graveyard synergy
        if "from your graveyard" in oracle_text or "graveyard" in oracle_text:
            synergies.append({
                "mechanic": "recursion",
                "synergy_type": "enables",
                "strength": 0.9,
                "reason": "Commander enables graveyard strategies"
            })
        
        # Token synergy
        if "token" in oracle_text:
            synergies.append({
                "mechanic": "token_generation",
                "synergy_type": "benefits_from",
                "strength": 0.8,
                "reason": "Commander synergizes with tokens"
            })
        
        # Cost reduction synergy
        if "cost" in oracle_text and "less" in oracle_text:
            synergies.append({
                "mechanic": "cost_reduction",
                "synergy_type": "provides",
                "strength": 0.7,
                "reason": "Commander reduces costs"
            })
        
        # Card draw synergy
        if "draw" in oracle_text:
            synergies.append({
                "mechanic": "card_draw",
                "synergy_type": "provides",
                "strength": 0.7,
                "reason": "Commander provides card draw"
            })
        
        # Create relationships
        for synergy in synergies:
            query_synergy = """
            MATCH (c:Commander {name: $commander_name})
            MERGE (m:Mechanic {name: $mechanic_name})
            MERGE (c)-[:SYNERGIZES_WITH_MECHANIC {
                synergy_type: $synergy_type,
                strength: $strength,
                reason: $reason
            }]->(m)
            """
            
            conn.execute_query(query_synergy, {
                "commander_name": commander_name,
                "mechanic_name": synergy["mechanic"],
                "synergy_type": synergy["synergy_type"],
                "strength": synergy["strength"],
                "reason": synergy["reason"]
            })
        
        print(f"✓ Analyzed '{commander_name}': found {len(synergies)} synergies")
        return synergies

# Usage
engine = SynergyInferenceEngine()
engine.analyze_commander(conn, "Muldrotha, the Gravetide")
```

---

### **Phase 6: Query Interface**

#### **Step 6.1: Deckbuilding Query Functions**

```python
class DeckbuildingQueries:
    """Pre-built queries for deckbuilding recommendations."""
    
    @staticmethod
    def find_synergistic_cards(conn: Neo4jConnection, 
                              commander_name: str,
                              max_cmc: int = 4,
                              min_strength: float = 0.7,
                              limit: int = 50) -> list[dict]:
        """Find cards that synergize with commander via shared mechanics."""
        
        query = """
        MATCH (cmd:Commander {name: $commander_name})
              -[s:SYNERGIZES_WITH_MECHANIC]->(m:Mechanic)
              <-[:HAS_MECHANIC]-(card:Card)
        WHERE card.cmc <= $max_cmc
          AND s.strength >= $min_strength
          AND NOT card:Commander
        RETURN DISTINCT card.name AS name,
               card.mana_cost AS mana_cost,
               card.type_line AS type,
               card.cmc AS cmc,
               card.oracle_text AS text,
               m.name AS shared_mechanic,
               s.strength AS synergy_strength,
               card.functional_categories AS roles
        ORDER BY s.strength DESC, card.cmc ASC
        LIMIT $limit
        """
        
        return conn.execute_query(query, {
            "commander_name": commander_name,
            "max_cmc": max_cmc,
            "min_strength": min_strength,
            "limit": limit
        })
    
    @staticmethod
    def find_known_combos(conn: Neo4jConnection, 
                         card_name: str) -> list[dict]:
        """Find explicitly documented combos from MTGJSON."""
        
        query = """
        MATCH (c1:Card {name: $card_name})
              -[r:COMBOS_WITH {source: "mtgjson_spellbook"}]->(c2:Card)
        RETURN c2.name AS combo_piece,
               c2.oracle_text AS text,
               c2.mana_cost AS cost,
               c2.cmc AS cmc
        ORDER BY c2.cmc ASC
        """
        
        return conn.execute_query(query, {"card_name": card_name})
    
    @staticmethod
    def find_token_generators(conn: Neo4jConnection,
                             token_type: str,
                             color_identity: list[str] = None,
                             max_cmc: int = None) -> list[dict]:
        """Find all cards that create a specific token."""
        
        query = """
        MATCH (card:Card)-[:CREATES_TOKEN]->(t:Token {name: $token_type})
        WHERE ($color_identity IS NULL OR 
               ALL(color IN card.color_identity WHERE color IN $color_identity))
          AND ($max_cmc IS NULL OR card.cmc <= $max_cmc)
        RETURN card.name AS name,
               card.mana_cost AS cost,
               card.cmc AS cmc,
               card.type_line AS type,
               card.oracle_text AS text
        ORDER BY card.cmc ASC
        """
        
        return conn.execute_query(query, {
            "token_type": token_type,
            "color_identity": color_identity,
            "max_cmc": max_cmc
        })
    
    @staticmethod
    def find_cards_by_role(conn: Neo4jConnection,
                          role: str,
                          color_identity: list[str],
                          max_cmc: int = 3,
                          min_efficiency: float = 0.6) -> list[dict]:
        """Find efficient cards for a functional role in colors."""
        
        query = """
        MATCH (card:Card)-[r:FILLS_ROLE]->(role:Functional_Role {name: $role})
        WHERE ALL(color IN card.color_identity WHERE color IN $color_identity)
          AND card.cmc <= $max_cmc
          AND r.efficiency_score >= $min_efficiency
        RETURN card.name AS name,
               card.mana_cost AS mana_cost,
               card.cmc AS cmc,
               r.efficiency_score AS efficiency,
               r.conditionality AS conditionality,
               card.oracle_text AS text
        ORDER BY r.efficiency_score DESC, card.cmc ASC
        LIMIT 20
        """
        
        return conn.execute_query(query, {
            "role": role,
            "color_identity": color_identity,
            "max_cmc": max_cmc,
            "min_efficiency": min_efficiency
        })
    
    @staticmethod
    def build_deck_shell(conn: Neo4jConnection,
                        commander_name: str) -> dict:
        """Build a deck shell with role distribution (8x8 method)."""
        
        # Define role distribution
        roles_needed = {
            "ramp": 9,
            "card_draw": 9,
            "removal": 9,
            "protection": 5,
            "win_condition": 5
        }
        
        # Get commander color identity
        query_colors = """
        MATCH (cmd:Commander {name: $commander_name})
        RETURN cmd.color_identity AS colors
        """
        result = conn.execute_query(query_colors, {"commander_name": commander_name})
        
        if not result:
            return {"error": f"Commander '{commander_name}' not found"}
        
        colors = result[0]["colors"]
        
        deck_shell = {
            "commander": commander_name,
            "color_identity": colors,
            "cards_by_role": {}
        }
        
        # Find synergistic cards for each role
        for role, count in roles_needed.items():
            query_cards = """
            MATCH (cmd:Commander {name: $commander_name})
                  -[s:SYNERGIZES_WITH_MECHANIC]->(m:Mechanic)
                  <-[:HAS_MECHANIC]-(card:Card)
                  -[:FILLS_ROLE]->(r:Functional_Role {name: $role})
            WHERE NOT card:Commander
            RETURN DISTINCT card.name AS name,
                   card.mana_cost AS cost,
                   card.cmc AS cmc,
                   s.strength AS synergy
            ORDER BY s.strength DESC, card.cmc ASC
            LIMIT $count
            """
            
            cards = conn.execute_query(query_cards, {
                "commander_name": commander_name,
                "role": role,
                "count": count
            })
            
            deck_shell["cards_by_role"][role] = cards
        
        return deck_shell
    
    @staticmethod
    def find_combo_packages(conn: Neo4jConnection,
                           commander_name: str) -> list[dict]:
        """Find known combo packages relevant to commander."""
        
        query = """
        MATCH (cmd:Commander {name: $commander_name})
              -[:SYNERGIZES_WITH_MECHANIC]->(m:Mechanic)
              <-[:HAS_MECHANIC]-(c1:Card)
              -[combo:COMBOS_WITH {source: "mtgjson_spellbook"}]->(c2:Card)
        RETURN DISTINCT c1.name AS piece1,
               c2.name AS piece2,
               c1.cmc AS cmc1,
               c2.cmc AS cmc2,
               m.name AS shared_mechanic
        ORDER BY (c1.cmc + c2.cmc) ASC
        """
        
        return conn.execute_query(query, {"commander_name": commander_name})

# Usage examples in main function below
```

---

## Complete Pipeline Script

```python
#!/usr/bin/env python3
"""
Commander Knowledge Graph - Complete Pipeline
MTGJSON version with RelatedCards integration
"""

import json
import requests
import os
import re
from neo4j import GraphDatabase


def main():
    """Execute complete pipeline."""
    
    print("=" * 60)
    print("Commander Deckbuilding Knowledge Graph")
    print("MTGJSON v5 | RelatedCards Integration")
    print("=" * 60)
    print()
    
    # Phase 1: Download MTGJSON data
    print("PHASE 1: Data Acquisition")
    print("-" * 60)
    
    downloader = MTGJSONDownloader()
    files = downloader.download_all()
    
    # Phase 2: Parse card data
    print("\nPHASE 2: Data Parsing")
    print("-" * 60)
    
    print("Parsing AtomicCards...")
    parser = AtomicCardsParser()
    cards = parser.parse(files["atomic_cards"])
    
    print("\nParsing RelatedCards...")
    related_parser = RelatedCardsParser()
    related_cards = related_parser.parse(files["related_cards"])
    
    # Phase 3: Enrich data
    print("\nPHASE 3: Property Extraction")
    print("-" * 60)
    
    enriched_cards = enrich_card_data(cards)
    
    # Phase 4: Connect to Neo4j
    print("\nPHASE 4: Database Connection")
    print("-" * 60)
    
    conn = Neo4jConnection(
        uri="bolt://localhost:7687",
        user="neo4j",
        password="your_password_here"  # ⚠️ CHANGE THIS
    )
    conn.create_constraints()
    
    # Phase 5: Load cards
    print("\nPHASE 5: Loading Cards")
    print("-" * 60)
    
    batch_load_cards(conn, enriched_cards)
    
    # Phase 6: Create basic relationships
    print("\nPHASE 6: Creating Relationships")
    print("-" * 60)
    
    print("Creating mechanic relationships...")
    for i, card in enumerate(enriched_cards):
        create_mechanic_relationships(conn, card)
        if (i + 1) % 1000 == 0:
            print(f"  Processed {i + 1}/{len(enriched_cards)}...")
    
    print("\nCreating role relationships...")
    for i, card in enumerate(enriched_cards):
        create_role_relationships(conn, card)
        if (i + 1) % 1000 == 0:
            print(f"  Processed {i + 1}/{len(enriched_cards)}...")
    
    # Phase 7: Integrate RelatedCards ✨ NEW
    print("\nPHASE 7: Integrating RelatedCards")
    print("-" * 60)
    
    integrate_related_cards(conn, related_cards)
    
    # Phase 8: Infer commander synergies
    print("\nPHASE 8: Commander Synergy Analysis")
    print("-" * 60)
    
    popular_commanders = [
        "Muldrotha, the Gravetide",
        "Korvold, Fae-Cursed King",
        "Chulane, Teller of Tales",
        "The Gitrog Monster",
        "Kinnan, Bonder Prodigy",
        "Yuriko, the Tiger's Shadow",
        "Tymna the Weaver",
        "Thrasios, Triton Hero"
    ]
    
    engine = SynergyInferenceEngine()
    for commander in popular_commanders:
        engine.analyze_commander(conn, commander)
    
    # Phase 9: Example queries
    print("\nPHASE 9: Example Queries")
    print("-" * 60)
    
    print("\n1. Cards that synergize with Muldrotha:")
    muldrotha_cards = DeckbuildingQueries.find_synergistic_cards(
        conn,
        commander_name="Muldrotha, the Gravetide",
        max_cmc=4,
        min_strength=0.7,
        limit=10
    )
    
    for i, card in enumerate(muldrotha_cards, 1):
        print(f"  {i}. {card['name']} ({card['mana_cost']}) - {card['shared_mechanic']}")
    
    print("\n2. Known combos with Dramatic Reversal:")
    combos = DeckbuildingQueries.find_known_combos(
        conn,
        card_name="Dramatic Reversal"
    )
    
    for combo in combos:
        print(f"  → {combo['combo_piece']} ({combo['cost']})")
    
    print("\n3. Goblin token generators in Jund:")
    goblin_gens = DeckbuildingQueries.find_token_generators(
        conn,
        token_type="Goblin",
        color_identity=["B", "R", "G"],
        max_cmc=4
    )
    
    for card in goblin_gens[:5]:
        print(f"  • {card['name']} ({card['cost']})")
    
    # Summary
    print("\n" + "=" * 60)
    print("PIPELINE COMPLETE")
    print("=" * 60)
    print(f"✓ Loaded {len(enriched_cards)} cards")
    print(f"✓ Integrated {len(related_cards)} card relationships")
    print(f"✓ Analyzed {len(popular_commanders)} commanders")
    print()
    print("Database ready for queries!")
    print("Connection: bolt://localhost:7687")
    print()
    
    conn.close()


if __name__ == "__main__":
    main()
```

---

## Usage Examples

### **Example 1: Find Cards for Commander**

```python
conn = Neo4jConnection("bolt://localhost:7687", "neo4j", "password")

# Find synergistic cards
cards = DeckbuildingQueries.find_synergistic_cards(
    conn,
    commander_name="Muldrotha, the Gravetide",
    max_cmc=4,
    min_strength=0.7
)

for card in cards[:10]:
    print(f"{card['name']} - {card['shared_mechanic']} (synergy: {card['synergy_strength']})")
```

**Output:**
```
Eternal Witness - etb_trigger (synergy: 0.9)
Spore Frog - recursion (synergy: 0.9)
Sakura-Tribe Elder - dies_trigger (synergy: 0.9)
Plaguecrafter - etb_trigger (synergy: 0.9)
...
```

---

### **Example 2: Find Known Combos**

```python
# Find what Dramatic Reversal combos with
combos = DeckbuildingQueries.find_known_combos(
    conn,
    card_name="Dramatic Reversal"
)

for combo in combos:
    print(f"Combo piece: {combo['combo_piece']} ({combo['cost']})")
```

**Output:**
```
Combo piece: Isochron Scepter ({2})
```

---

### **Example 3: Find Token Generators**

```python
# Find Goblin token generators in Jund colors
goblins = DeckbuildingQueries.find_token_generators(
    conn,
    token_type="Goblin",
    color_identity=["B", "R", "G"],
    max_cmc=5
)

for card in goblins:
    print(f"{card['name']} ({card['cost']}) - {card['type']}")
```

**Output:**
```
Krenko, Mob Boss ({2}{R}{R}) - Legendary Creature — Goblin
Siege-Gang Commander ({3}{R}{R}) - Creature — Goblin
Mogg War Marshal ({1}{R}) - Creature — Goblin Warrior
...
```

---

### **Example 4: Build Deck Shell**

```python
# Build a deck shell for Korvold
shell = DeckbuildingQueries.build_deck_shell(
    conn,
    commander_name="Korvold, Fae-Cursed King"
)

print(f"Commander: {shell['commander']}")
print(f"Colors: {', '.join(shell['color_identity'])}")
print()

for role, cards in shell["cards_by_role"].items():
    print(f"{role.upper()} ({len(cards)} cards):")
    for card in cards[:3]:  # Show top 3
        print(f"  • {card['name']} ({card['cost']})")
    print()
```

**Output:**
```
Commander: Korvold, Fae-Cursed King
Colors: B, R, G

RAMP (9 cards):
  • Sol Ring ({1})
  • Elvish Mystic ({G})
  • Sakura-Tribe Elder ({1}{G})

CARD_DRAW (9 cards):
  • Phyrexian Arena ({1}{B}{B})
  • Dark Confidant ({1}{B})
  • Sylvan Library ({1}{G})
...
```

---

### **Example 5: Find Combo Packages**

```python
# Find combos relevant to Kinnan
combos = DeckbuildingQueries.find_combo_packages(
    conn,
    commander_name="Kinnan, Bonder Prodigy"
)

for combo in combos:
    total_cmc = combo['cmc1'] + combo['cmc2']
    print(f"{combo['piece1']} + {combo['piece2']} (Total CMC: {total_cmc})")
    print(f"  Mechanic: {combo['shared_mechanic']}")
    print()
```

---

## Next Steps

### **Week 1: Setup & Initial Load**
- [ ] Install Neo4j Desktop or Community Edition
- [ ] Run pipeline script to download data
- [ ] Load first 1000 cards to test
- [ ] Validate graph structure with sample queries

### **Week 2: Full Data Load**
- [ ] Load all ~20,000 Commander-legal cards
- [ ] Create all mechanic/role relationships
- [ ] Integrate RelatedCards fully
- [ ] Validate combo detection

### **Week 3: Commander Analysis**
- [ ] Analyze top 50 commanders for synergies
- [ ] Test synergy queries
- [ ] Compare results to manual deck analysis
- [ ] Refine synergy detection rules

### **Week 4: Query Optimization**
- [ ] Test all query functions
- [ ] Measure query performance
- [ ] Add indexes for slow queries
- [ ] Document query patterns

### **Week 5: Validation & Refinement**
- [ ] Compare recommendations to known deck lists
- [ ] Identify gaps in coverage
- [ ] Refine text parsing patterns
- [ ] Document edge cases

---

## Ready to Implement!

This complete implementation plan includes:

✅ MTGJSON data sources (AtomicCards, Keywords, RelatedCards)
✅ Complete graph ontology with all node/relationship types
✅ Text parsing for functional roles and mechanics
✅ Explicit combo detection from RelatedCards
✅ Token relationship tracking
✅ Commander synergy inference
✅ Query interface for deckbuilding recommendations
✅ Complete pipeline script ready to run

**All code is ready for Claude Code to execute!** 🎲🔧